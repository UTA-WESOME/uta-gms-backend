from typing import Dict, List, Tuple

import utagmsengine.dataclasses as uged

from ..models import (
    Alternative,
    Category,
    Criterion,
    Inconsistency,
    PairwiseComparison,
    Performance,
    PreferenceIntensity,
    Project,
    Ranking
)
from ..serializers import (
    AcceptabilityIndexSerializer,
    FunctionPointSerializer,
    InconsistencySerializer,
    PairwiseWinningSerializer,
    RelationSerializer
)
from ..utils.recursive_queries import RecursiveQueries


class EngineConverter:
    """
    Utility class for converting and processing data between the UTA GMS Engine and the application's models.

    This class provides static methods for converting data from the application's models to the format expected by
    the UTA GMS Engine and vice versa. It also includes methods for inserting and updating various data types in the
    application's models based on data generated by the UTA GMS Engine.

    Static Methods:
    ---------------
    get_criteria(criteria: List[Criterion]) -> List[uged.Criterion]:
        Convert a list of application's Criteria instances to a list of uged.Criterion instances.

    get_performances(alternatives: List[Alternative], criteria: List[Criterion]) -> Dict[str, Dict[str, float]]:
        Convert performance data from the application's models to a dictionary format expected by the Uta GMS Engine.

    get_comparisons(project: Project, categories: List[Category]) -> List[uged.Comparison]:
        Convert pairwise comparison data from the application's models to a list of uged.Comparison instances.

    get_preference_intensities(
            project: Project, categories: List[Category], criteria: List[Criterion]
    ) -> List[uged.Intensity]:
        Convert preference intensity data from the application's models to a list of uged.Intensity instances.

    get_best_worst_positions(categories: List[Category]) -> List[uged.Position]:
        Convert best and worst position data from the application's models to a list of uged.Position instances.

    insert_inconsistencies_comparisons(
            category_root: Category, comparisons: List[uged.Comparison], group: int
    ) -> None:
        Insert inconsistency data for pairwise comparisons into the application's models.

    insert_inconsistencies_best_worst(
            category_root: Category, best_worsts: List[uged.Position], group: int
    ) -> None:
        Insert inconsistency data for best and worst positions into the application's models.

    insert_inconsistencies_preference_intensities(
            category_root: Category, intensities: List[uged.Intensity], group: int
    ) -> None:
        Insert inconsistency data for preference intensities into the application's models.

    insert_inconsistencies(
            category_root: Category,
            inconsistencies: Tuple[List[uged.Comparison], List[uged.Comparison], List[uged.Position], List[uged.Intensity]]
    ) -> None:
        Insert various inconsistency data into the application's models.

    insert_acceptability_indices(category_root: Category, indices: Dict[str, List[float]]) -> None:
        Insert acceptability indices into the application's models.

    insert_pairwise_winnings(category_root: Category, winnings: Dict[str, List[str]]) -> None:
        Insert pairwise winning data into the application's models.

    update_rankings(category_root: Category, ranking: Dict[str, float]) -> None:
        Update ranking data in the application's models.

    insert_criterion_functions(category_root: Category, functions: Dict[str, List[Tuple[float, float]]]) -> None:
        Insert criterion function data into the application's models.

    insert_relations(category_root: Category, relations: Dict[str, List[str]], relation_type: str) -> None:
        Insert relation data into the application's models.
    """

    @staticmethod
    def get_criteria(criteria: List[Criterion]) -> List[uged.Criterion]:
        """
        Convert a list of Django Criterion instances to a list of utagmsengine.Criterion instances.

        Parameters
        ----------
        criteria : List[Criterion]
            A list of Django Criterion instances.

        Returns
        -------
        List[uged.Criterion]
            A list of uged.Criterion instances.
        """
        return [
            uged.Criterion(criterion_id=str(c.id), number_of_linear_segments=c.linear_segments, gain=c.gain)
            for c in criteria
        ]

    @staticmethod
    def get_performances(alternatives: List[Alternative], criteria: List[Criterion]) -> Dict[str, Dict[str, float]]:
        """
        Retrieve performances for a list of alternatives and criteria.

        Parameters
        ----------
        alternatives : List[Alternative]
            A list of Django Alternative instances.
        criteria : List[Criterion]
            A list of Django Criterion instances.

        Returns
        -------
        Dict[str, Dict[str, float]]
            A dictionary representing performances for each alternative and criterion.
            The keys of the outer dictionary are alternative IDs, and the inner dictionaries
            have criterion IDs as keys and corresponding performances as values.
        """
        performances = {}
        for alternative in alternatives:
            performances[str(alternative.id)] = {
                str(criterion_id): value for criterion_id, value in
                Performance.objects
                .filter(alternative=alternative)
                .filter(criterion__in=criteria)
                .values_list('criterion', 'value')
            }
        return performances

    @staticmethod
    def get_comparisons(project: Project, categories: List[Category]) -> List[uged.Comparison]:
        """
        Retrieve comparisons for a project and a list of categories.

        Parameters
        ----------
        project : Project
            A Django Project instance.
        categories : List[Category]
            A list of Django Category instances.

        Returns
        -------
        List[uged.Comparison]
            A list of Comparison instances representing pairwise comparisons or rankings.

        Notes
        -----
        If the project is in pairwise mode, it retrieves pairwise comparisons.
        If not, it generates comparisons based on rankings within each category.
        """
        comparisons_list = []
        if project.pairwise_mode:
            for pairwise_comparison in PairwiseComparison.objects.filter(category__in=categories):
                # we have to find criteria that the pairwise comparison is related to
                criteria_for_comparison = Criterion.objects.filter(
                    id__in=RecursiveQueries.get_criteria_for_category(pairwise_comparison.category.id)
                )
                comparisons_list.append(
                    uged.Comparison(
                        alternative_1=str(pairwise_comparison.alternative_1.id),
                        alternative_2=str(pairwise_comparison.alternative_2.id),
                        criteria=[str(criterion.id) for criterion in criteria_for_comparison],
                        sign=pairwise_comparison.type
                    )
                )
        else:
            for category in categories:
                criteria_for_category = RecursiveQueries.get_criteria_for_category(category.id)
                rankings = Ranking.objects.filter(category=category)
                # we get unique ranking values and sort them
                reference_ranking_unique_values = list(set(rankings.values_list('reference_ranking', flat=True)))
                reference_ranking_unique_values.sort()
                # now we need to check every alternative and find other alternatives that are below this alternative in
                # reference_ranking
                for ranking_1 in rankings:
                    # 0 in reference_ranking means that it was not placed in the reference ranking
                    if ranking_1.reference_ranking == 0:
                        continue
                    # we have to get the index in the reference_ranking_unique_values of the current ranking's
                    # reference_ranking value
                    rr_index = reference_ranking_unique_values.index(ranking_1.reference_ranking)
                    for ranking_2 in rankings:
                        if ranking_1.id == ranking_2.id:
                            continue
                        if (
                                # we need to skip checking if the rr_index is the last one in the unique ranking,
                                # otherwise we will out of bounds for the reference_ranking_unique_values list
                                # when doing rr_index + 1
                                rr_index < len(reference_ranking_unique_values) - 1
                                and ranking_2.reference_ranking == reference_ranking_unique_values[rr_index + 1]
                        ):
                            comparisons_list.append(uged.Comparison(
                                alternative_1=str(ranking_1.alternative.id),
                                alternative_2=str(ranking_2.alternative.id),
                                criteria=[str(criterion.id) for criterion in criteria_for_category],
                                sign=PairwiseComparison.PREFERENCE
                            ))
                        if ranking_2.reference_ranking == reference_ranking_unique_values[rr_index]:
                            comparisons_list.append(uged.Comparison(
                                alternative_1=str(ranking_1.alternative.id),
                                alternative_2=str(ranking_2.alternative.id),
                                criteria=[str(criterion.id) for criterion in criteria_for_category],
                                sign=PairwiseComparison.INDIFFERENCE
                            ))
        return comparisons_list

    @staticmethod
    def get_preference_intensities(
            project: Project,
            categories: List[Category],
            criteria: List[Criterion]
    ) -> List[uged.Intensity]:
        """
        Retrieve preference intensities for a project, defined on categories and criteria.

        Parameters
        ----------
        project : Project
            A Django Project instance.
        categories : List[Category]
            A list of Django Category instances.
        criteria : List[Criterion]
            A list of Django Criterion instances.

        Returns
        -------
        List[uged.Intensity]
            A list of Intensity instances representing preference intensities.

        Notes
        -----
        Preference intensities can be defined on the whole category or on a specific criterion.
        """
        preference_intensities_list = []
        for preference_intensity in PreferenceIntensity.objects.filter(project=project):
            # intensity defined on the whole category
            if preference_intensity.category in categories:
                # get criteria for this category
                criteria_for_intensity = Criterion.objects.filter(
                    id__in=RecursiveQueries.get_criteria_for_category(preference_intensity.category.id)
                )
                preference_intensities_list.append(
                    uged.Intensity(
                        alternative_id_1=str(preference_intensity.alternative_1.id),
                        alternative_id_2=str(preference_intensity.alternative_2.id),
                        alternative_id_3=str(preference_intensity.alternative_3.id),
                        alternative_id_4=str(preference_intensity.alternative_4.id),
                        criteria=[str(criterion.id) for criterion in criteria_for_intensity],
                        sign=preference_intensity.type
                    )
                )
            # intensity defined on a criterion
            if preference_intensity.criterion in criteria:
                preference_intensities_list.append(
                    uged.Intensity(
                        alternative_id_1=str(preference_intensity.alternative_1.id),
                        alternative_id_2=str(preference_intensity.alternative_2.id),
                        alternative_id_3=str(preference_intensity.alternative_3.id),
                        alternative_id_4=str(preference_intensity.alternative_4.id),
                        criteria=[str(preference_intensity.criterion.id)],
                        sign=preference_intensity.type
                    )
                )
        return preference_intensities_list

    @staticmethod
    def get_best_worst_positions(categories: List[Category]) -> List[uged.Position]:
        """
        Retrieve best and worst positions for alternatives within specified categories.

        Parameters
        ----------
        categories : List[Category]
            A list of Django Category instances.

        Returns
        -------
        List[uged.Position]
            A list of Position instances representing best and worst positions for alternatives.

        Notes
        -----
        The best and worst positions are determined within the specified categories.
        """
        best_worst_positions_list = []
        for category in categories:
            rankings_count = Ranking.objects.filter(category=category).count()
            criteria_for_category = RecursiveQueries.get_criteria_for_category(category.id)
            for ranking in Ranking.objects.filter(category=category):
                if ranking.best_position is not None and ranking.worst_position is not None:
                    best_worst_positions_list.append(uged.Position(
                        alternative_id=str(ranking.alternative.id),
                        worst_position=ranking.worst_position,
                        best_position=ranking.best_position,
                        criteria=[str(criterion.id) for criterion in criteria_for_category]
                    ))
                elif ranking.best_position is not None:
                    best_worst_positions_list.append(uged.Position(
                        alternative_id=str(ranking.alternative.id),
                        worst_position=rankings_count,
                        best_position=ranking.best_position,
                        criteria=[str(criterion.id) for criterion in criteria_for_category]
                    ))
                elif ranking.worst_position is not None:
                    best_worst_positions_list.append(uged.Position(
                        alternative_id=str(ranking.alternative.id),
                        worst_position=ranking.worst_position,
                        best_position=1,
                        criteria=[str(criterion.id) for criterion in criteria_for_category]
                    ))
        return best_worst_positions_list

    @staticmethod
    def insert_inconsistencies_comparisons(
            category_root: Category,
            comparisons: List[uged.Comparison],
            group: int
    ) -> None:
        """
        Insert inconsistencies based on a list of comparisons within the specified category.

        Parameters
        ----------
        category_root : Category
            The root category for which inconsistencies will be inserted.
        comparisons : List[uged.Comparison]
            A list of Comparison instances containing information about pairwise comparisons.
        group : int
            The group identifier for the inconsistencies.

        Notes
        -----
        This method takes a list of uta-gms-engine Comparison instances and inserts inconsistencies into the specified
        category based on the provided comparisons.
        """
        for comparison in comparisons:
            # get names of the alternatives
            name_1 = Alternative.objects.get(id=int(comparison.alternative_1)).name
            name_2 = Alternative.objects.get(id=int(comparison.alternative_2)).name
            criteria_names = Criterion.objects \
                .filter(id__in=[int(_id) for _id in comparison.criteria]) \
                .values_list('name', flat=True)
            comparison_type = comparison.sign
            i_serializer = InconsistencySerializer(data={
                'group': group,
                'data': f"{name_1} {comparison_type} {name_2} on {', '.join(criteria_names)}",
                'type': comparison_type
            })
            if i_serializer.is_valid():
                i_serializer.save(category=category_root)

    @staticmethod
    def insert_inconsistencies_best_worst(
            category_root: Category,
            best_worsts: List[uged.Position],
            group: int
    ) -> None:
        """
        Insert inconsistencies based on a list of best-worst positions within the specified category.

        Parameters
        ----------
        category_root : Category
            The root category for which inconsistencies will be inserted.
        best_worsts : List[uged.Position]
            A list of Position instances containing information about best-worst positions.
        group : int
            The group identifier for the inconsistencies.

        Notes
        -----
        This method takes a list of uged.Position instances representing best-worst positions and inserts
        inconsistencies into the specified category based on the provided positions.
        """
        for best_worst in best_worsts:
            name = Alternative.objects.get(id=int(best_worst.alternative_id)).name
            criteria_names = Criterion.objects \
                .filter(id__in=[int(_id) for _id in best_worst.criteria]) \
                .values_list('name', flat=True)
            i_serializer = InconsistencySerializer(data={
                'group': group,
                'data': f"{name} - best position {best_worst.best_position}, worst position {best_worst.worst_position}"
                        f" on {', '.join(criteria_names)}",
                'type': Inconsistency.POSITION
            })
            if i_serializer.is_valid():
                i_serializer.save(category=category_root)

    @staticmethod
    def insert_inconsistencies_preference_intensities(
            category_root: Category,
            intensities: List[uged.Intensity],
            group: int
    ) -> None:
        """
        Insert inconsistencies based on a list of preference intensities within the specified category.

        Parameters
        ----------
        category_root : Category
            The root category for which inconsistencies will be inserted.
        intensities : List[uged.Intensity]
            A list of Intensity instances containing information about preference intensities.
        group : int
            The group identifier for the inconsistencies.

        Notes
        -----
        This method takes a list of uged.Intensity instances representing preference intensities and inserts
        inconsistencies into the specified category based on the provided intensities.
        """
        for intensity in intensities:
            name_1 = Alternative.objects.get(id=int(intensity.alternative_id_1)).name
            name_2 = Alternative.objects.get(id=int(intensity.alternative_id_2)).name
            name_3 = Alternative.objects.get(id=int(intensity.alternative_id_3)).name
            name_4 = Alternative.objects.get(id=int(intensity.alternative_id_4)).name
            criteria_names = Criterion.objects \
                .filter(id__in=[int(_id) for _id in intensity.criteria]) \
                .values_list('name', flat=True)
            intensity_sign = intensity.sign
            i_serializer = InconsistencySerializer(data={
                'group': group,
                'data': f"{name_1} - {name_2} {intensity_sign} {name_3} - {name_4} on {', '.join(criteria_names)}",
                'type': intensity_sign
            })
            if i_serializer.is_valid():
                i_serializer.save(category=category_root)

    @staticmethod
    def insert_inconsistencies(
            category_root: Category,
            inconsistencies: Tuple[
                List[uged.Comparison], List[uged.Comparison], List[uged.Position], List[uged.Intensity]
            ]
    ) -> None:
        """
        Insert inconsistencies into the specified category based on different groups of inconsistencies.

        Parameters
        ----------
        category_root : Category
            The root category for which inconsistencies will be inserted.
        inconsistencies : Tuple[List[uged.Comparison], List[uged.Comparison], List[uged.Position], List[uged.Intensity]]
            A tuple containing lists of different types of inconsistencies (comparisons, best-worst positions,
            preference intensities).

        Notes
        -----
        This method takes a tuple containing lists of different types of inconsistencies and inserts them into the specified
        category. The inconsistencies include comparisons, best-worst positions, and preference intensities. Each group of
        inconsistencies is associated with a unique group identifier.
        """
        for i, inconsistencies_group in enumerate(inconsistencies, start=1):
            i_comparisons, i_best_worst, i_intensities = inconsistencies_group

            EngineConverter.insert_inconsistencies_comparisons(category_root, i_comparisons, i)
            EngineConverter.insert_inconsistencies_best_worst(category_root, i_best_worst, i)
            EngineConverter.insert_inconsistencies_preference_intensities(category_root, i_intensities, i)

    @staticmethod
    def insert_acceptability_indices(category_root: Category, samples: Dict[str, List[float]]) -> None:
        """
        Insert acceptability indices values into the specified category for different alternatives.

        Parameters
        ----------
        category_root : Category
            The root category for which percentage values will be inserted.
        samples : Dict[str, List[float]]
            A dictionary where keys are alternative identifiers and values are lists of percentage values.

        Notes
        -----
        This method takes a dictionary of alternative identifiers and corresponding lists of percentage values and inserts
        them as AcceptabilityIndex instances into the specified category. Each alternative's indices are associated with
        distinct positions.
        """
        for key, percentages_data in samples.items():
            for i, value in enumerate(percentages_data):
                acceptability_index_serializer = AcceptabilityIndexSerializer(data={
                    'position': i + 1,
                    'percent': value,
                    'alternative': int(key)
                })
                if acceptability_index_serializer.is_valid():
                    acceptability_index_serializer.save(category=category_root)

    @staticmethod
    def insert_pairwise_winnings(category_root, pairwise_winnings: Dict[str, Dict[str, float]]) -> None:
        """
        Insert pairwise winning acceptability indices into the database for the specified category.

        This method takes a dictionary where keys are alternative IDs, and values are dictionaries representing the
        pairwise winning acceptability indices against other alternatives. It inserts these pairwise winning
        acceptability indices into the database and associates them with the specified category.

        Parameters:
        -----------
        category_root : Category
            The root category for which the pairwise winning percentages are to be inserted.
        pairwise_winnings : Dict[str, Dict[str, float]]
            A dictionary where keys are alternative IDs, and values are dictionaries representing pairwise winning
            acceptability indices against other alternatives.
        """
        for key_1, percentages in pairwise_winnings.items():
            for key_2, percentage in percentages.items():
                pairwise_winning_serializer = PairwiseWinningSerializer(data={
                    'percent': percentage,
                    'alternative_1': int(key_1),
                    'alternative_2': int(key_2)
                })
                if pairwise_winning_serializer.is_valid():
                    pairwise_winning_serializer.save(category=category_root)

    @staticmethod
    def update_rankings(category_root: Category, ranking: Dict[str, float]) -> None:
        """
        Update rankings for alternatives in the specified category based on the provided ranking dictionary.

        Parameters
        ----------
        category_root : Category
            The root category for which rankings will be updated.
        ranking : Dict[str, float]
            A dictionary where keys are alternative identifiers, and values are corresponding ranking values.

        Notes
        -----
        This method updates the rankings of alternatives within the specified category. The ranking dictionary should
        contain alternative identifiers as keys and their associated ranking values. The alternatives are ranked in descending
        order based on their ranking values, and the rankings are updated accordingly.
        """
        for i, (key, value) in enumerate(sorted(ranking.items(), key=lambda x: -x[1]), start=1):
            ranking = Ranking.objects.filter(alternative_id=int(key)).filter(category=category_root).first()
            ranking.ranking = i
            ranking.ranking_value = value
            ranking.save()

    @staticmethod
    def insert_criterion_functions(category_root: Category, functions: Dict[str, List[Tuple[float, float]]]) -> None:
        """
        Insert criterion functions into the specified category based on the provided functions dictionary.

        Parameters
        ----------
        category_root: Category
            The root category for which criterion functions will be inserted.
        functions: Dict[str, List[Tuple[float, float]]]
            A dictionary where keys are criterion identifiers, and values are lists of tuples representing
            (abscissa, ordinate) pairs for the criterion function.

        Notes
        -----
        This method inserts criterion functions into the specified category. The functions dictionary should contain
        criterion identifiers as keys, and the corresponding values should be lists of tuples representing (abscissa, ordinate)
        pairs for the criterion function. Multiple points define a function for a particular criterion.
        """
        for criterion_id, function in functions.items():
            for x, y in function:
                point = FunctionPointSerializer(data={
                    'ordinate': y,
                    'abscissa': x,
                    'criterion': int(criterion_id)
                })
                if point.is_valid():
                    point.save(category=category_root)

    @staticmethod
    def insert_relations(category_root: Category, relations: Dict[str, List[str]], relation_type: str) -> None:
        """
        Insert relations into the specified category based on the provided relations dictionary.

        Parameters
        ----------
        category_root : Category
            The root category for which relations will be inserted.
        relations : Dict[str, List[str]]
            A dictionary where keys are alternative identifiers, and values are lists of alternative identifiers
            representing relations.
        relation_type : str
            The type of relations - necessary or possible.

        Notes
        -----
        This method inserts relations into the specified category. The relations dictionary should contain alternative
        identifiers as keys, and the corresponding values should be lists of alternative identifiers representing
        relations. Each alternative can have multiple dependencies.
        """
        for alternative_id, dependent in relations.items():
            for d_alternative in dependent:
                relation = RelationSerializer(data={
                    'type': relation_type,
                    'alternative_1': int(alternative_id),
                    'alternative_2': int(d_alternative)
                })
                if relation.is_valid():
                    relation.save(category=category_root)

    @staticmethod
    def update_extreme_ranks(category_root: Category,
                             extreme_ranks: Dict[str, Tuple[Tuple[int, int], Tuple[int, int]]]) -> None:
        """
        Update extreme rank positions for the specified category.

        This method updates the extreme rank positions (pessimistic and optimistic) for each alternative in the provided
        dictionary. The dictionary keys are alternative IDs, and values are tuples representing extreme rank positions.

        Parameters:
        -----------
        category_root : Category
            The root category for which the extreme rank positions are to be updated.
        extreme_ranks : Dict[str, Tuple[Tuple[int, int], Tuple[int, int]]]
            A dictionary where keys are alternative IDs, and values are tuples representing extreme rank positions. The
            first tuple represents pessimistic ranks (worst and best), and the second tuple represents optimistic ranks.
        """
        for key, extreme_positions in extreme_ranks.items():
            ranking = Ranking.objects.filter(alternative_id=int(key)).filter(category=category_root).first()
            ranking.extreme_pessimistic_worst = extreme_positions[0][0]
            ranking.extreme_pessimistic_best = extreme_positions[0][1]
            ranking.extreme_optimistic_worst = extreme_positions[1][0]
            ranking.extreme_optimistic_best = extreme_positions[1][1]
            ranking.save()
